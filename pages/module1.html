<!DOCTYPE html>
<html>
<title>Module 1: Memory</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Roboto'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!--Syntax highlighting import-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/c.min.js"></script>


    <script>hljs.highlightAll();</script>

<!--Style block-->
    <style>
    html,body,h1,h2,h3,h4,h5,h6 {font-family: "Lucida Console", "Courier New", monospace}
    </style>

    <style type="text/css">
        .tab { margin-left: 40px; }
    </style>

<!--Body -->
<body class="w3-light-blue">

<!-- Navbar (sit on top) -->
<div class="w3-top">
  <div class="w3-bar w3-grey w3-text-white" id="myNavbar">
    <a href="/repository" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-home"></i> MODULES</a>
    <a href="#home" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-home"></i> HOME</a>
    <a href="#code" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-briefcase"></i> CODING</a>
    <a href="#computermemory" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-desktop"></i> 1: COMPUTER MEMORY</a>
    <a href="#pointers" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> 2: POINTERS</a>
    <a href="#s2practice" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> 2: PRACTICE </a>
    <a href="#advanced" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> 3: ADVANCED POINTERS </a>
    <a href="#heap" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> 4: HEAP ALLOCATION </a>
  </div>

<!-- Navbar on small screens -->
  <div id="navDemo" class="w3-bar-block w3-blue w3-hide w3-hide-large w3-hide-medium">
    <a href="/repository" class="w3-bar-item w3-button" onclick="toggleFunction()">MODULES</a>
    <a href="#home" class="w3-bar-item w3-button" onclick="toggleFunction()">HOME</a>
    <a href="#code" class="w3-bar-item w3-button" onclick="toggleFunction()">CODING</a>
    <a href="#computermemory" class="w3-bar-item w3-button" onclick="toggleFunction()">1: COMPUTER MEMORY</a>
    <a href="#pointers" class="w3-bar-item w3-button" onclick="toggleFunction()">2: POINTERS</a>
    <a href="#s2practice" class="w3-bar-item w3-button" onclick="toggleFunction()">2: PRACTICE</a>
    <a href="#advanced" class="w3-bar-item w3-button" onclick="toggleFunction()">3: ADVANCED POINTERS</a>
    <a href="#heap" class="w3-bar-item w3-button" onclick="toggleFunction()">4: HEAP ALLOCATION</a>
  </div>
</div>

<!-- Page Container -->
<div class="w3-content w3-margin-top" style="max-width:1500px;">

  <!-- The Center Column -->
  <div class="w3-row-padding">

    
<!-- Column -->
    <div class="w3-threethird">
    <br> <br> <!--to shift it all down-->
    
<!-- Opening Section -->
      <div id="home" class="w3-container w3-card w3-light-grey">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-home fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> MODULE 1: Pointers, References, and Memory Allocation</h1>
        <div class="w3-container">
          <h5 class="w3-text-black w3-text-center w3-padding-0"> 
            This module contains resources for learning about pointers and memory in computer science. 
            The module discusses these concepts in terms of the programming language C. 
            Many of the same concepts apply to other programming languages.
            <br><br>
            The module contains multiple sections beginning with a discussion of how memory works in C.
            <br><br>
            It is best to start with Section 1. Before section 1 is an embedded instance of OnlineGDB, an editing environment that allows you to write and compile C code online.
            <br><br>
            Table of Contents:<br>
            1: <a href="#code" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-briefcase"></i> C Programming Environment</a><br>
            2: <a href="#computermemory" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-desktop"></i> Section 1: Computer Memory Basics</a><br>
            3: <a href="#pointers" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> Section 2: Pointers</a><br>
            4: <a href="#s2practice" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> Section 2 Practice Problems </a><br>
            5: <a href="#advanced" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> Section 3: Advanced Pointer Concepts Including Double Pointers, Void Pointers, and Pointer Math </a><br>
            6: <a href="#heap" class="w3-bar-item w3-btn w3-hover-blue w3-hide-small"><i class="fa fa-asterisk"></i> Section 4: Dynamic Memory Allocation and Deallocation on the Heap </a><br>
          </h5>
          <br>
          
          
        </div>
      </div>
      <br>

<!-- Code Environment -->
      <div id="code" class="w3-threethird">
        <div id="home" class="w3-container w3-card w3-light-grey">
            <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-briefcase fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> C CODING Environment</h1>
            <div class="w3-container">
                <iframe width="1420" height="1500" id="editor" src="https://www.onlinegdb.com/online_c_compiler"></iframe>
            </div>
        </div>
      </div>

      <br><br>


<!--Section 1: COMPUTER MEMORY-->
      <div id = "computermemory" class="w3-container w3-card w3-light-grey">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-desktop fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> Section 1: COMPUTER MEMORY</h1>
        
        <h5 class="w3-text-black w3-text-center w3-padding-0"> 
            Computers much like our brains need to have the ability to store, hold, and work with information. 
            Typically we consider people to have short and long term memories. 
            Short term memories are things we need to hold in our brains for a short time, such as the next step in a recipe when we are cooking. 
            Long term memories are things we store for a longer time, such as meaningful events and things we have learned. 
            <br><br> 
            Computers work in much the same way. 
            In our computer we have short term memory, commonly referred to as Random Access Memory or RAM.
            We also have long term memory or storage, typical in the form of a hard disk drive (HDD) or solid state drive (SSD).
            On our HDD or SSD, we find the files on our computer.
            In our RAM, we find the programs and files that are currently open or actively in use. 
            Memory is typically referred to in terms of bits. 
            8 bits make up a byte of memory. 
            Typically ram in current computers are gigabytes in size, with 8 to 32 gigabytes being commonplace amounts in consumer computers.
            In terms of programming, it is this RAM we care about the most. 
        </h5>
        <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fnetworkustad.com%2Fwp-content%2Fuploads%2F2019%2F05%2Fbandwidth-table.png&f=1&nofb=1&ipt=07de49dc538b81206f309b7cc8730855f071c82634d827ef7d5e3ea0d9bed1eb&ipo=images" alt="bit conversion table" style="width:800px;height:600px;">
        <br>
        <br>
        <h5 class="w3-text-black w3-text-center w3-padding-0">
            When we are programming in some languages, including C or C++, we have direct access to the RAM that our program is assigned. 
            This assignment of memory is done by our computer and the compiler, but we need to give it directions for it to work properly.
            Memory in a computer can be thought of as being very similar to that of houses on a street. 
            Each section of memory has an address. 
            This address allows us to refer to what is held at this specific location in memory and keeps memory organized much like house addresses allow us to refer to a specific address on a road.
            These addresses refer to specifically one byte of memory. 
            Memory addresses are represented using hexademical. The following are examples of valid memory addresses:
            
            <pre><code class="language-c">
                0x00000000001<br>
                0x00034AEEFC2<br>
                0xDEADBEEF<br>
                0x3A39AFE45
            </code></pre>

            As we can see, these addresses all have some things in common. 
            Because they are hexadecimal numbers, we start them with the characters <code class="w3-text-blue">0x</code>.
            These characters tell us that the following number is represented in base 16, or hexadecimal. 
            Because the number is hexadecimal, it is composed of the following characters: <code class="w3-text-blue">0 1 2 3 4 5 6 7 8 9 A B C D E F</code>.
            <br><br>

            The memory in our computer that we access in our programs are divided commonly into two types: the stack and the heap. 
            The stack consists primarily of primitives such as integers, longs, and doubles. 
            The stack behaves exactly as it sounds. 
            On a stack, new elements (variables) are added to the top. 
            Elements are also removed from the top of stack as we finish using them. 
            This organizational pattern is called First-In-Last-Out or FILO. 
            These primitives have a specific size in terms of how much memory these use.
            For example, an integer in a modern computer is 4 bytes or 32 bits in size. 
            Below are examples of how we might create variables that will reside on this stack. 
            
            <pre><code class="language-c"> 
                int x = 44; #32 bit integer <br>
                int y = 13; #32 bit integer <br>
                long int ex = 4398; #64 bit integer <br>
                double dub = 188.1114; #64 bit float  
            </code></pre> 
        
            Creating variables in our code on the stack is very simple and does not require any additional steps. 
            This is known as static memory allocation because we do not need to do anything to allocate memory for these variables. 
            Our program compiler takes care of this step for us because it knows based on the type of our variable how much memory it needs to allocate on this stack.
            For example, 
            <pre><code class="language-c"> int x = 44;</code></pre> 
            is easy for the compiler to figure out. 
            It knows that the type is int, which needs 4 bytes of memory regardless of what the value is that we want to store.
            We can even reassign this variable to a different value later and the amount of memory needed doesn't change. 
            <br><br>
            The heap, on the other hand, behaves quite a bit differently. 
            We can think of the heap as being a large mountain of memory.
            Just like before, the heap has addresses to refer to each byte of memory.
            However, we now need to specify in our code the amount of memory we actually want to use. 
            This is because the heap allows us to define more complicated and larger things in our code.
            For example, strings, arrays, and Objects (C++) are placed on this heap. 
            However, because their size is not guarunteed, we need to assign how much space on the heap we actually need for these elements.
            
        </h5>
        <img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Funicminds.com%2Fwp-content%2Fuploads%2F2022%2F09%2FStackvsHeap-Expalined-for-Kids.png&f=1&nofb=1&ipt=4d96076ba9648c7870a23db0ebbabdf1db2e4491b1365e01b47e21f62e28eeec&ipo=images" alt="The stack and heap" style="width:800px;height:600px;">
        <br>
        <br>
        <h5 class="w3-text-black w3-text-center w3-padding-0">
            In section 2, below, we will discuss the concept of pointers, which are something we will need to further explore the heap. 
            In section 3, we will explore more advanced uses of pointers and references beyond their basic usage.
            In section 4, we will continue looking at this idea of the heap. 
            <br><br>

            This section has been composed from the following sources. If you want additional resources, see the following links and videos:
            <br>
            Relevant Links:
            <br>
            <a href=https://www.geeksforgeeks.org/static-and-dynamic-memory-allocation-in-c/>Basics of Memory and static memory addressing</a> <br>
            <a href="https://www.w3schools.com/c/c_memory_management.php">W3Schools Memory in C</a>
            <br><br>

            Relevant Videos: 
            <br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/xyBbocLXbNY?si=qFf9Ji71ihNPol6P" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br><br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/1KVpi0VN82E?si=0Ep_ssdhyhbSULc0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        </h5>
        
      </div>
      <br>

<!--Section 2: POINTERS-->
      <div id="pointers" class="w3-container w3-card w3-light-grey">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-asterisk fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> SECTION 2: POINTERS</h1>
        
        <h5 class="w3-text-black w3-text-center w3-padding-0"> 
            In the previous section we began discussing memory in a computer. 
            In this section, we saw that creating primitive variables on the stack such as ints, longs, and doubles are very simple and the space they take up is assigned statically by the compiler when our code is executed. 
            We also saw that the heap is our other area of memory we can access in our programs. 
            This section will explore how we can refer to things we create on this heap, pointers.
            <br><br>
            First, lets take a slight detour and consider the other side of this coin: references. 
            References are specifically an address in memory. 
            They are the physical location of a value in memory. 
            For example, consider the following code: 
            
            <pre><code class="language-c">
                int x = 43; <br>
                printf("%p \n",&x);
            </code></pre>
            
            If we run this code, we'll find that the printf statement will print a value that looks like a memory address.
            If you are confused by the printf statement, the following is a video explaining printf in C. 
            <br><br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/yBLApvS7fcY?si=dFWGJwdR48zCgZih" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br><br>
            What is printed here is actually just the memory address where our variable x is being stored on the stack. 
            The <code class="w3-text-blue">&</code> symobol means we want to access the location of the variable x.
            We'll use this knowledge now to create a pointer.
            Pointers are as simple as they sound; a pointer is a variable created to provide a reference to an address in memory we want to access. 
            This address then provides us access to something in memory we wish to work with more. 
            Let us consider an example of a pointer and break down it's components.
            
            <pre><code class="language-c">
                int x = 43; <br>
                int* y = &x;
            </code></pre>
            
            On this first line, we create a variable in the same way we normally would. 
            In this line we assign the value of 43 to the int variable x. 
            Now lets say we want to be able to create a pointer to x.
            To do this we say int*.
            The * here tells our compiler that what we are trying to create is a pointer. 
            We then set our pointer variable y to be equal to a reference to x (&x).
            The & here means we want to make a reference to the variable x.
            What we are saying here is we want to create an int pointer y that is equal to the address of x. 
            This allows us to do two different things. 
            It allows us to access the value that has been assigned to the variable x through the reference. 
            It also assigns y a value of the address where our variable x has been stored. 
            Let us continue looking at our example from before:

            <pre><code class="language-c">
            int main(){
                int x = 43; <br>
                int* y = &x; <br>
                printf("Value at y = %p \n", y); <br>
                printf("Value at x = %d \n", x); <br>
                printf("Value at &y = %d \n", *y);
                return 0;
            }
            </code></pre>

            This code will print the following three lines when it is printed:
            
            <pre><code class="language-c">
            >     Value at y = 0x3A39AFE45 <br>
            >     Value at x = 43 <br>
            >     Value at *y = 43
            </code></pre>
            
            Here we see that our pointer y can be used for two things. 
            When we state *y this means we can access the VALUE that our pointer is pointing to.
            When we do this, we get the value stored at the memory address our pointer is pointing to. 
            In this case it is the value assigned to the variable x, <code class="w3-text-blue">43</code>.
            When we state y by itself then we get the value assigned to y, which as it's a pointer, is the address in memory we're pointing to. 
            In this case, we get the value <code class="w3-text-blue"> 0x3A39AFE45 </code> because thats the address in memory where our variable x is located.
            <br> <br>
            And thats the basics for pointers and references.
            In section 3 we'll explore this concept further and look at some more complex examples. 
            This section contains some example questions below it. 
            For these try and work on them yourself, then view the hidden answers by clicking on them. 
            <br><br> 

            Relevant Links:
            <br>
            <a href=https://www.geeksforgeeks.org/c-pointers/>Pointers in C</a> <br>
            <a href="https://www.w3schools.com/c/c_pointers.php">W3Schools Pointers in C</a>
            <br><br>

            Relevant Videos: 
            <br>
            
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/2ybLD6_2gKM?si=xqM6dMSLEjN73DcR" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br> <br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/i49_SNt4yfk?si=2ogULNn4r9zlKHEX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br><br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/qclZUQYZTzg?si=Pm5lfYg2lm_n-2aG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br><br>
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/47IS8VtAM9E?si=7FIf0rbRTKL7yr3R" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br><br> 
            <iframe width="1000" height="600" src="https://www.youtube.com/embed/DplxIq0mc_Y?si=tJCQ49qhH7cPgG1k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <br>

        </h5>
        <br>
        
      </div>
      <br>

<!--Section 2 Practice Problems-->
      <div id= s2practice class="w3-container w3-card w3-light-grey w3-padding-large">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-asterisk fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> SECTION 2: PRACTICE</h1>
        <h5 class="w3-text-black w3-text-center w3-padding-0"> 
            <b class="w3-text-blue w3-text-theme=bold">Question 1:</b>
            Given the following code snippet what will be printed when this is executed?
            <pre><code class="language c"> 
                int main(){
                    int datum = 300; 
                    int* ptr = &datum; 
                    int ptrval = *ptr; 

                    printf("%d \n",datum); 
                    printf("%p \n",ptr); 
                    printf("%d \n",*ptr); 
                    printf("%d \n",ptrval);
                    return 0;
                }
                </code></pre>
            
            <details class="w3-text-blue">
                <summary class="w3-text-black">Answer</summary>
                <pre><code class="language-c">
                    300 <br>
                    0xAEC43532 #(the address of datum) <br>
                    300 <br>
                    00 <br>
                </code></pre>
                

            </details>
           
            <details class="w3-text-black">
                <summary>Explanation</summary>
                Our first print statement here is quite straightforward. 
                It simply prints the value associated with our variable datum. <br>
                Our second print statement here will print the address that our pointer is pointing to. <br>
                Our third print statement here requests the value that our pointer variable ptr is pointing to, so the value of datum, or 300. <br>
                Our fourth print statement works similarly to our third, except instead of accessing the value we are pointing to using ptr, we have a new variable ptrval that has been set rqul to the value that ptr is pointing at.
            </details>

        </h5>
        <br>
      </div>
      <br>

<!--Section 3 Advanced Pointer Concepts-->
      <div id="advanced" class="w3-container w3-card w3-light-grey w3-padding-large">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-asterisk fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> SECTION 3: ADVANCED POINTER CONCEPTS</h1>
        <h5 class="w3-text-black w3-text-center w3-padding-0">
            In our last section we discussed the basic uses of pointers and references!
            Now we're going to look at some more advanced uses of pointers. 
            In the next section, we'll explore using these pointers for dynamic memory allocation. 
            <br> <br>
            This section will consider three specific concepts: double pointers, void pointers, and pointer math.
            <br><br>
            </h5>
            <h2 class="w3-text-blue w3-text-center w3-padding-0">3.1: Double Pointers </h2>
            <h5 class="w3-text-black w3-text-center w3-padding-0">
            Consider the following section of code.
            <pre><code class="language-c">
              int main(){
                int val = 5;
                int *pval = &val;
                int **d_pval = &pval;
                printf("Value of val = %d\n", val);
                printf("Value of val using single pointer = %d\n", *pval);
                printf("Value of var using double pointer = %d\n", **d_pval);

                return 0;
              }

              >Value of val = 5
              >Value of val using a single pointer = 5
              >Value of val using a double pointer = 5

            </code></pre>
            As we can see in this code we are defining three different variables. 
            val is a simple integer with value 5. 
            pval is a simple pointer much like what we've seen in section 2. 
            d_pval is a pointer that we have defined to point to our first pointer.
            This is a pointer to a pointer or a double pointer.
            Let's consider another example, this time in terms of what's happening in memory.
            As we can see in the image below we have var which is a variable with value 10.
            ptr1 is a regular pointer. 
            Its value is the memory address (location) of our variable var. 
            ptr2 is a double pointer. 
            Its value is the memory address (location) of our pointer ptr1. 
            <br><br>
            <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230412184414/double-pointers-in-c.webp" alt="bit conversion table" style="width:800px;height:600px;"> 
            <br><br>
            </h5>

            <h2 class="w3-text-blue w3-text-center w3-padding-0">3.2: Void Pointers </h2>

            <h5 class="w3-text-black w3-text-center w3-padding-0">
              So far with pointers we have defined pointers as having the same datatype as the data we are pointing to. 
              Void pointers are a type of pointer that can point to any type of data and has no associated data type.
              Consider the following block of code:
              <pre><code class="language-c">
                int main(){
                  int a = 10;
                  char b = 'x';
 
                  // void pointer holds address of int 'a'
                  void *p = &a;
                  // void pointer reassigned to hold address of char 'b'
                  p = &b;
                  }  
              </code></pre>

              In this code, we define two variables a and b, with a being an int and b being a char.
              We also have defined our void pointer, named p. 
              At first, we see that p has been assigned a reference to our variable a. 
              However, we can seamlessly reassign p to a reference to our variable b, despite the fact that a and b are different types of data.
              This is great because we can access and reassign our pointer any time we want to anything we want. 
              Getting access to the address we are pointing to is easy.
              However, getting access to the value that we are pointing at is tricky. 
              If we were to run the code below we would receive an error from the C compiler.
              Relevant Links:<br>
              <pre><code>
                printf("%d", *p);
              </code></pre>
              This is because C needs to know the type of the data we are referring to when we dereference the pointer to get the value we are pointing to.
              Instead, when we need access to the value we are pointing to we need to use the following code wherein we specify the type we are referring to when we dereference the pointer. 
              <pre><code>
                printf("%d",*(int*)ptr);
              </code></pre>
              <br><br>
            </h5>

            <h2 class="w3-text-blue w3-text-center w3-padding-0">3.2: Pointer Arithmetic </h2>

            <h5 class="w3-text-black w3-text-center w3-padding-0">
              So far we have seen how to define double pointers and how to create void pointers. 
              One other concept that we often need to do is what is known as pointer arithmetic.
              Pointers simply reference a specific address in memory as we have established. 
              Sometimes we want to reference a different address in memory than what we initially had referenced. 
              Sometimes we can do this simply by reassigning the pointer to a new address manually. 
              However, other times we cannot. 
              Take for example the following code: 
              <pre><code>
                int main(){
                  int arr[2] = {34,56};
                  void* parr = &arr;

                  printf("%d",*(int*)parr);

                  parr = parr+sizeof(int);
                  printf("%d",*(int*)parr);

                  return 0;
                }
              </code></pre>
              In this example, we see that inside of our function, we first define an array containing two integers, 34 and 56. 
              When we define a pointer to this array, we use a void pointer once more. 
              The void pointer starts out pointing to the 0th index of the array. 
              We can see this when we run the code and receive the following outputs. 
              <pre><code>
                >34
                >56
              </code></pre>
              The first print statement prints out 34 because our pointer initially references the address of the 0th index of our array. 
              Then we modify our pointer by adding the size of an integer. 
              This shifts the pointer to point to the next address in memory or the next element in the array. 
              We can do this for arrays of any other type. We can also use this to shift by larger amounts or structs. 
              We can even use this to iterate over arrays or other data structures. 
              We will see some of this in section 4 where we explore Malloc and heap memory allocation. 
              <br><br>
            <a href="https://www.mycplus.com/tutorials/c-programming-tutorials/double-pointer-to-pointer-in-c/">Double Pointers Examples</a> <br>
            <a href="https://dev.to/noah11012/double-pointers-in-cc-2n96">Double Pointers Examples</a>

            <br><br>
            
            Relevant Videos: <br>
        </h5>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/k6ESk9zafHM?si=l6M-YebDlzmdcrI6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/q24-QTbKQS8?si=bk4hurpk2GvTjpEk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/t7CUti_7d7c?si=K4V5HhdvqZEdyF50" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/Vd-4eGnBAK8?si=3DaoWLQEraVm2EuN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/8T0WOABe7OY?si=SKofWfKLEr8dF4-_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br>
 
      </div>
      <br>

<!--Section 4 Dynamic Memory Allocation-->
      <div id="heap" class="w3-container w3-card w3-light-grey w3-padding-large">
        <h1 class="w3-text-blue w3-padding-16"><i class="fa fa-asterisk fa-fw w3-margin-right w3-xxlarge w3-text-blue"></i> SECTION 4: DYNAMIC MEMORY ALLOCATION</h1>
        <h5 class="w3-text-black w3-text-center w3-padding-0">
          Previously, we have looked at pointers, references, how to use them, and how stack memory allocation works. 
          Thus far, all of the memory we have allocated has been on the stack.  
          This includes variables and larger elements such as arrays which we looked at in the previous section with pointer math.
          The heap is our other area of memory in our computer. 
          The heap can be considered to be a larger, unordered section of memory that needs to be managed manually. 
          To store stuff on the heap we need to utilise a memory allocator. 
          C happens to have an excellent built in memory allocator called Malloc which we will be considering today.
          Malloc allows us to simply specify the size of memory on the heap we want to allocate and the memory will be allocated for us. 
          We don't need to do anything else.
          However, this means that we need to have some idea of how much memory we are going to need prior to allocating it. 
          Malloc is a function within C that we can call that takes as a parameter the size in bytes that we want to allocate. 
          Let us consider the following code involving integers and allocating an integer array for 100 integers to the heap.
          <pre><code>
            int main(){
              int* p = (int*) malloc(400);

              return 0;
            }
          </code></pre>
          Here we have define a pointer utilising malloc to allocate some memory on our heap.
          Specifically we have allocated 400 bytes. 
          Since an integer is 4 bytes this is room for an array of 100 integers. 
          If we wanted to allocate a different number of integers or just speficy the number of integers we could instead do:
          <pre><code>
            int main(){
              int* p = (int*) malloc(200*sizeof(int));

              return 0;
            }
          </code></pre> 
          This code should work to allocate a section of memory.
          However, sometimes it is possible we will have run out of memory on the heap that we can allocate. 
          When this happens our pointer will fail to be allocated. 
          We can check this with the following:
          <pre><code>
            int main(){
              int* p = (int*) malloc(200*sizeof(int));
              if (p == NULL) {
                printf("memory failed to allocate. \n");
              }

              return 0;
            }
          </code></pre>
          If our memory has been allocated correctly, we can now populate the array and access the array elements using our pointer and pointer arithmetic like we saw in the last section.
          For example, lets set each of the elements in an array of size 200 to be equal to the numbers 1-200 in order. 
          <pre><code>
            int main(){
              int i;
              int* p = (int*) malloc(200*sizeof(int));
              if (p == NULL) {
                printf("memory failed to allocate. \n");
              }
              else{
                for(i = 0; i < 200; i++){
                  p[i]=i+1;
                }
              }
              //print the elements
              for(i=0; i< 200; i++){
                printf("%d, ",p[i]);
              }

              return 0;
            }
          </code></pre>
          In this code block we have allocated 800 bytes for 200 integers, populated the memory, and printed out the results to our terminal.
          When we execute this code, we will receive the numbers 1 to 200 printed out. 
          <br><br>
          Just like how we need to allocate memory we need to also free that memory up. 
          We need to do this before we finish our code. 
          Else we experience what is known as a memory leak. 
          A memory leak just means that we have allocated memory that we can no longer access.
          Because of this the memory is taken up but we have no way of accessing it or freeing it. 
          To avoid this happening, we need to use something called free(). 
          free() simply allows us to dynamically de-allocate memory. 
          Consider the following code, which is very similar to our code before but now contains a free() call. 
          <pre><code>
            int main(){
              int i;
              int* p = (int*) malloc(200*sizeof(int));
              if (p == NULL) {
                printf("memory failed to allocate. \n");
              }
              else{
                for(i = 0; i < 200; i++){
                  p[i]=i+1;
                }
              }
              //print the elements
              for(i=0; i< 200; i++){
                printf("%d, ",p[i]);
              }

              //dynamically deallocate memory
              free(p);
              p=NULL;
              return 0;
            }
          </code></pre>
          Here the code is almost the same until the last two steps.
          The first step is calling free() a function built into C. 
          free() takes in our pointer and frees the memory that has been allocated using the pointer. 
          Secondly, we set our pointer to be equal to NULL. 
          This means that we cannot try and access the memory after it has been deallocated which can be done and should be avoided. 
          This can cause severe issues including potential security issues. 
          <br><br>
          Congrats! We have reached the end of Module 1 for now! 
          More content will be added in the future but this is the basics of memory allocation both static and dynamic. 
          <br><br>

            Below are video resources with a number of different explanations for how Pointers work in memory. 
        </h5>
        <h5 class="w3-text-black w3-text-center w3-padding-0"> 
            The videos are listed in order similarly to how the written sections above are organized.  
        </h5>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/ryyCnpS3eOc?si=Jo0DhdImjNkSk6JF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/wDUiDd3KmAA?si=8fTVq9S9aBe8ywJs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/udfbq4M2Kfc?si=fbWUci3iklelEZ0l" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/5OJRqkYbK-4?si=p8xBimzxw6S10SXw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <br><br>
        <iframe width="1000" height="600" src="https://www.youtube.com/embed/OiynRs3iKzI?si=5fbfkrGLaUXP738k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        <br>
 
      </div>
      <br>
        
        <br><br>
 
    </div>

    <!-- End Right Column -->
    </div>

  <!-- End Grid -->
  </div>

  <!-- End Page Container -->
</div>

<footer class="w3-container w3-blue w3-center w3-margin-top">
  <p> </p>
  <a href="./repository.html" class=" w3-btn w3-white w3-text-blue w3-round-large "><i class="fa fa-home"></i> BACK TO REPOSITORY</a>
  <p>Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a></p>
  <p>The code environment on this page is brought to you by <a href="onlinegdb.com">OnlineGDB.com</a></p>

</footer>

</body>
</html>